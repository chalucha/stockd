/**
 * 
 * /home/tomas/workspace/trading/stockd/source/stockd/ta/templates.d
 * 
 * Author:
 * Tomáš Chaloupka <chalucha@gmail.com>
 * 
 * Copyright (c) 2015 ${CopyrightHolder}
 * 
 * Boost Software License 1.0 (BSL-1.0)
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy
 * of the software and accompanying documentation covered by this license (the "Software") to use,
 * reproduce, display, distribute, execute, and transmit the Software, and to prepare derivative
 * works of the Software, and to permit third-parties to whom the Software is furnished to do so,
 * all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license
 * grant, this restriction and the following disclaimer, must be included in all copies of the Software,
 * in whole or in part, and all derivative works of the Software, unless such copies or derivative works
 * are solely in the form of machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
 * PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE
 * DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
module stockd.ta.templates;

/**
 * Template for EMA calculation
 * Params:
 *  period = period for EMA
 *  useSma = use SMA instead of EMA for 0..period-1 values
 */ 
mixin template Ema(bool useSma = true)
{
    private double _m1, _m2;
    private bool _hasVal;
    private ushort _idx;
    private double _lastVal = 0;
    private ushort _period;

    void initialize(ushort per = 12) pure nothrow @nogc
    {
        _period = per;
        _m1 = 2.0/(1 + _period);
        _m2 = 1 - _m1;
    }

    double eval(double value) pure nothrow @nogc
    {
        if(!_hasVal)
        {
            static if(useSma)
            {
                _lastVal += value;
                _idx++;
                
                if(_idx == _period) 
                {
                    _hasVal = true;
                    _lastVal /= _idx;
                    return _lastVal;
                }
                
                return _lastVal / _idx;
            }
            else
            {
                _lastVal = value;
                _hasVal = true;
                
                return value;
            }
        }
        
        _lastVal = value * _m1 + _lastVal * _m2; 
        
        return _lastVal;
    }
}

/**
 * Template for SMA calculation
 */
mixin template Sma()
{
    private ushort _period;
    private bool _isFull;
    private double _lastSum = 0;
    private ushort _idx;
    private double[] _buffer;

    void initialize(ushort period = 12) pure nothrow
    {
        assert(period > 0);
        
        _period = period;
        _buffer = new double[period];
    }

    double eval(double value) pure nothrow @nogc
    {
        if(!_isFull)
        {
            _buffer[_idx++] = value;
            _lastSum += value;
            
            if(_idx == _period)
            {
                _idx = 0;
                _isFull = true;
                return _lastSum / _period;
            }
            
            return _lastSum / _idx;
        }
        
        _lastSum -= _buffer[_idx];
        _buffer[_idx++] = value;
        _lastSum += value;
        if(_idx == _period) _idx = 0;
        
        return _lastSum / _period;
    }
}

/**
 * Template fof min or max evaluaton for time period
 */
mixin template MinMax(bool min = true)
{
    private ushort _period;
    private ushort _idx;
    private bool _isBuffFull;
    private double _minmax = min ? int.max : int.min;
    private double[] _buffer;
    
    void initialize(ushort period = 14) pure nothrow
    {
        assert(period > 0);
        
        _period = period;
        _buffer = new double[period];
    }
    
    double eval(double value) pure nothrow @nogc
    {
        bool gen = false;
        if (_isBuffFull)
        {
            if (_minmax == _buffer[_idx]) gen = true;
            else
            {
                static if(min)
                {
                    if (value < _minmax) _minmax = value;
                }
                else
                {
                    if (value > _minmax) _minmax = value;
                }
            }
        }
        else
        {
            static if(min)
            {
                if (value < _minmax) _minmax = value;
            }
            else
            {
                if (value > _minmax) _minmax = value;
            }
        }
        
        _buffer[_idx++] = value;
        if (_idx == _period)
        {
            _isBuffFull = true;
            _idx = 0;
        }
        
        if (gen == true)
        {
            _minmax = _buffer[0];
            for (ushort i = 1; i < _period; i++)
            {
                static if(min)
                {
                    if (_buffer[i] < _minmax) _minmax = _buffer[i];
                }
                else
                {
                    if (_buffer[i] > _minmax) _minmax = _buffer[i];
                }
            }
        }
        
        return _minmax;
    }
}

/**
 * Template for standard deviation calculation
 */
mixin template StdDev(bool withAverage = false)
{
    import stockd.ta.templates : Sma;
    mixin Sma sma;

    void initialize(ushort perd) pure nothrow
    {
        assert(perd > 0);

        sma.initialize(perd);
    }

    auto eval(double value) pure nothrow @nogc
    {
        import std.math : sqrt;
        static if(withAverage) import std.typecons : tuple;
        
        auto avg = sma.eval(value);
        
        if(!sma._isFull && sma._idx == 1) 
        {
            static if(withAverage) return tuple(avg, 0.0);
            else return 0.0;
        }
        
        //count stddev
        double sum = 0;
        for(ushort i = 0; i < (sma._isFull ? sma._period: sma._idx); i++)
        {
            sum += (sma._buffer[i] - avg)*(sma._buffer[i] - avg);
        }

        static if(withAverage)
            return tuple(avg, sqrt(sum / (sma._isFull ? sma._period : sma._idx)));
        else
            return sqrt(sum / (sma._isFull ? sma._period : sma._idx));
    }
}


/**
 * Template for true range calculation
 */
mixin template TrueRange()
{
    import stockd.defs.bar;

    private double _prevClose = double.nan;

    private double eval(Bar bar) pure nothrow @nogc
    {
        import std.math : isNaN, abs;
        import std.algorithm : max;

        if(isNaN(_prevClose))
        {
            _prevClose = bar.close;
            return bar.high - bar.low;
        }

        double res = max(bar.high - bar.low, abs(bar.low - _prevClose), abs(bar.high - _prevClose));
        _prevClose = bar.close;

        return res;
    }
}
