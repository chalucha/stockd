/**
 * 
 * /home/tomas/workspace/trading/stockd/source/stockd/ta/templates.d
 * 
 * Author:
 * Tomáš Chaloupka <chalucha@gmail.com>
 * 
 * Copyright (c) 2015 ${CopyrightHolder}
 * 
 * Boost Software License 1.0 (BSL-1.0)
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy
 * of the software and accompanying documentation covered by this license (the "Software") to use,
 * reproduce, display, distribute, execute, and transmit the Software, and to prepare derivative
 * works of the Software, and to permit third-parties to whom the Software is furnished to do so,
 * all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license
 * grant, this restriction and the following disclaimer, must be included in all copies of the Software,
 * in whole or in part, and all derivative works of the Software, unless such copies or derivative works
 * are solely in the form of machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
 * PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE
 * DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
module stockd.ta.templates;

/**
 * Template for EMA calculation
 * Params:
 *  period = period for EMA
 *  useSma = use SMA instead of EMA for 0..period-1 values
 */ 
mixin template Ema(bool useSma = true)
{
    private double m1, m2;
    private bool hasVal;
    private ushort idx;
    private double lastVal = 0;
    private ushort period;

    void initialize(ushort per = 12)
    {
        period = per;
        m1 = 2.0/(1 + period);
        m2 = 1 - m1;
    }

    double eval(double value)
    {
        if(!hasVal)
        {
            static if(useSma)
            {
                lastVal += value;
                idx++;
                
                if(idx == period) 
                {
                    hasVal = true;
                    lastVal = lastVal / idx;
                    return lastVal;
                }
                
                return lastVal / idx;
            }
            else
            {
                lastVal = value;
                hasVal = true;
                
                return value;
            }
        }
        
        lastVal = value * m1 + lastVal * m2; 
        
        return lastVal;
    }
}

/**
 * Template for SMA calculation
 */
mixin template Sma()
{
    private ushort period;
    private bool isFull;
    private double lastSum = 0;
    private ushort idx;
    private double[] buffer;

    void initialize(ushort perd = 12)
    {
        assert(perd > 0);
        
        period = perd;
        buffer = new double[perd];
    }

    double eval(double value)
    {
        if(!isFull)
        {
            buffer[idx++] = value;
            lastSum += value;
            
            if(idx == period)
            {
                idx = 0;
                isFull = true;
                return lastSum / period;
            }
            
            return lastSum / idx;
        }
        
        lastSum -= buffer[idx];
        buffer[idx++] = value;
        lastSum += value;
        if(idx == period) idx = 0;
        
        return lastSum / period;
    }
}

mixin template MinMax(bool min = true)
{
    private ushort period;
    private ushort idx;
    private bool isBuffFull;
    private double minmax = min ? int.max : int.min;
    private double[] buffer;
    
    void initialize(ushort perd = 14)
    {
        assert(perd > 0);
        
        period = perd;
        buffer = new double[perd];
    }
    
    pure nothrow double eval(double value)
    {
        bool gen = false;
        if (isBuffFull)
        {
            if (minmax == buffer[idx]) gen = true;
            else
            {
                static if(min)
                {
                    if (value < minmax) minmax = value;
                }
                else
                {
                    if (value > minmax) minmax = value;
                }
            }
        }
        else
        {
            static if(min)
            {
                if (value < minmax) minmax = value;
            }
            else
            {
                if (value > minmax) minmax = value;
            }
        }
        
        buffer[idx++] = value;
        if (idx == period)
        {
            isBuffFull = true;
            idx = 0;
        }
        
        if (gen == true)
        {
            minmax = buffer[0];
            for (ushort i = 1; i < period; i++)
            {
                static if(min)
                {
                    if (buffer[i] < minmax) minmax = buffer[i];
                }
                else
                {
                    if (buffer[i] > minmax) minmax = buffer[i];
                }
            }
        }
        
        return minmax;
    }
}

mixin template StdDev(bool withAverage = false)
{
    import stockd.ta.templates : Sma;
    mixin Sma sma;

    void initialize(ushort perd)
    {
        assert(perd > 0);

        sma.initialize(perd);
    }

    auto eval(double value)
    {
        import std.math : sqrt;
        static if(withAverage) import std.typecons : tuple;
        
        auto avg = sma.eval(value);
        
        if(!sma.isFull && sma.idx == 1) 
        {
            static if(withAverage) return tuple(avg, 0.0);
            else return 0.0;
        }
        
        //count stddev
        double sum = 0;
        for(ushort i = 0; i < (sma.isFull ? sma.period: sma.idx); i++)
        {
            sum += (sma.buffer[i] - avg)*(sma.buffer[i] - avg);
        }

        static if(withAverage)
            return tuple(avg, sqrt(sum / (sma.isFull ? sma.period : sma.idx)));
        else
            return sqrt(sum / (sma.isFull ? sma.period : sma.idx));
    }
}
